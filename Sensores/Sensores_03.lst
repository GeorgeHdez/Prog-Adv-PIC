CCS PCH C Compiler, Version 5.015, 5967               05-Jan-16 21:02

               Filename:   E:\Git-Hub\Prog-Adv-PIC\Sensores\Sensores_03.lst

               ROM used:   870 bytes (3%)
                           Largest free fragment is 31898
               RAM used:   5 (0%) at main() level
                           41 (2%) worst case
               Stack used: 2 locations
               Stack size: 31

*
0000:  GOTO   02C2
.................... #include <Sensores_3.h> 
.................... //@ Instucciones de inicio @// 
.................... #include <18F4550.H> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  DATA 4C,65
0006:  DATA 74,72
0008:  DATA 61,20
000A:  DATA 4E,6F
000C:  DATA 20,45
000E:  DATA 73,70
0010:  DATA 65,63
0012:  DATA 69,66
0014:  DATA 69,63
0016:  DATA 61,64
0018:  DATA 61,00
*
029E:  TBLRD*+
02A0:  MOVF   FF5,F
02A2:  BZ    02BE
02A4:  MOVFF  FF6,09
02A8:  MOVFF  FF7,0A
02AC:  MOVF   FF5,W
02AE:  BTFSS  F9E.4
02B0:  BRA    02AE
02B2:  MOVWF  FAD
02B4:  MOVFF  09,FF6
02B8:  MOVFF  0A,FF7
02BC:  BRA    029E
02BE:  GOTO   0354 (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC = 10 
.................... #FUSES NOWDT,NOBROWNOUT,NOLVP,NOXINST 
.................... #use delay(crystal = 20Mhz) 
*
0202:  CLRF   FEA
0204:  MOVLW  0A
0206:  MOVWF  FE9
0208:  MOVF   FEF,W
020A:  BZ    0226
020C:  MOVLW  06
020E:  MOVWF  01
0210:  CLRF   00
0212:  DECFSZ 00,F
0214:  BRA    0212
0216:  DECFSZ 01,F
0218:  BRA    0210
021A:  MOVLW  7B
021C:  MOVWF  00
021E:  DECFSZ 00,F
0220:  BRA    021E
0222:  DECFSZ FEF,F
0224:  BRA    020C
0226:  RETURN 0
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #DEFINE l_1 PIN_D0 
.................... #DEFINE l_2 PIN_D1 
.................... #DEFINE limit_cort PIN_D2 
.................... #DEFINE limit_sensor PIN_D3 
.................... #DEFINE motor_pin_1 PIN_B0 
.................... #DEFINE motor_pin_2 PIN_B1 
.................... #DEFINE motor_pin_3 PIN_B2 
.................... #DEFINE motor_pin_4 PIN_B3 
....................  
.................... //@ Prototipos de Funciones @// 
....................  
.................... void ADC(); 
.................... void sampling_ADC(void); 
.................... void calibracion(void); 
.................... void send_info_rs232(int16,int16,int16,int16,int16); 
.................... int r_datos(void); 
.................... void corte_maquina(void); 
.................... void motor_s(int,char,char); 
.................... char sensor_start(void); 
.................... void cut_start(void); 
....................  
....................  
....................  
.................... Void main() { 
*
02C2:  CLRF   FF8
02C4:  BCF    FD0.7
02C6:  BSF    FB8.3
02C8:  MOVLW  2A
02CA:  MOVWF  FAF
02CC:  MOVLW  00
02CE:  MOVWF  FB0
02D0:  MOVLW  A6
02D2:  MOVWF  FAC
02D4:  MOVLW  90
02D6:  MOVWF  FAB
02D8:  MOVF   FC1,W
02DA:  ANDLW  C0
02DC:  IORLW  0F
02DE:  MOVWF  FC1
02E0:  MOVLW  07
02E2:  MOVWF  FB4
....................   /* code */ 
....................  
....................     setup_adc_ports(AN0_TO_AN8); 
02E4:  MOVF   FC1,W
02E6:  ANDLW  C0
02E8:  IORLW  06
02EA:  MOVWF  FC1
....................     setup_adc(ADC_CLOCK_DIV_2); 
02EC:  MOVF   FC0,W
02EE:  ANDLW  C0
02F0:  MOVWF  FC0
02F2:  BSF    FC0.7
02F4:  BSF    FC2.0
....................     while (TRUE) { 
....................       /* code */ 
....................       char opcion; 
....................       opcion = getc(); 
02F6:  BTFSS  F9E.5
02F8:  BRA    02F6
02FA:  MOVFF  FAE,05
....................  
....................       switch (opcion) { 
02FE:  MOVF   05,W
0300:  XORLW  78
0302:  BZ    0312
0304:  XORLW  1B
0306:  BZ    0316
0308:  XORLW  11
030A:  BZ    031A
030C:  XORLW  01
030E:  BZ    033A
0310:  BRA    034A
....................         case 'x': //ENVIA LAS LECTURAS DE LOS SENSORES 
....................         { 
....................           //printf("Enviando datos..."); 
....................           sampling_ADC(); 
0312:  BRA    006C
....................  
....................           break; 
0314:  BRA    0362
....................         } 
....................         case 'c': // CALIBRA LA MAQUINA MANDANDOLA AL ORIGEN 
....................         { 
....................           //printf("Calibrando..."); 
....................           calibracion(); 
0316:  BRA    015C
....................           break; 
0318:  BRA    0362
....................         } 
....................         case 'r': // RECIVE LOS DATOS DE LA PC 
....................         { 
....................           int repeat; 
....................           repeat = r_datos(); 
031A:  BRA    01CC
031C:  MOVFF  01,06
....................           cut_start(); 
0320:  BRA    01DC
....................           output_b(0x00); 
0322:  CLRF   F93
0324:  CLRF   F8A
....................           for (int i = 0; i < repeat; i++) { 
0326:  CLRF   07
0328:  MOVF   06,W
032A:  SUBWF  07,W
032C:  BC    0338
....................            corte_maquina(); 
032E:  BRA    0228
....................            output_b(0x00); 
0330:  CLRF   F93
0332:  CLRF   F8A
0334:  INCF   07,F
0336:  BRA    0328
....................           } 
....................             break; 
0338:  BRA    0362
....................         } 
....................         case 's':{ // PREPARA PARA EMPEZAR A SENSAR 
....................           char regreso; 
....................           regreso = sensor_start(); 
033A:  BRA    0274
033C:  MOVFF  01,08
....................  
....................           printf("%c",regreso); 
0340:  MOVF   08,W
0342:  BTFSS  F9E.4
0344:  BRA    0342
0346:  MOVWF  FAD
....................           break; 
0348:  BRA    0362
....................         } 
....................         default: 
....................         { 
....................           printf("Letra No Especificada"); 
034A:  MOVLW  04
034C:  MOVWF  FF6
034E:  MOVLW  00
0350:  MOVWF  FF7
0352:  BRA    029E
....................           delay_ms(1000); 
0354:  MOVLW  04
0356:  MOVWF  09
0358:  MOVLW  FA
035A:  MOVWF  0A
035C:  RCALL  0202
035E:  DECFSZ 09,F
0360:  BRA    0358
....................           break; 
....................         } 
....................       } 
0362:  BRA    02F6
....................     } 
....................  
.................... } 
.................... void send_info_rs232(int16 a, int16 b, int16 c, int16 d, int16 e){ // @ Envia los datos a la computadora en forma de caracteres @// 
0364:  SLEEP 
....................       char data[10]; 
....................       int x; 
....................  
....................       data[0] = a; 
*
001A:  MOVFF  14,1E
....................       data[1] = a>>8; 
001E:  MOVFF  15,1F
....................       data[2] = b; 
0022:  MOVFF  16,20
....................       data[3] = b>>8; 
0026:  MOVFF  17,21
....................       data[4] = c; 
002A:  MOVFF  18,22
....................       data[5] = c>>8; 
002E:  MOVFF  19,23
....................       data[6] = d; 
0032:  MOVFF  1A,24
....................       data[7] = d>>8; 
0036:  MOVFF  1B,25
....................       data[8] = e; 
003A:  MOVFF  1C,26
....................       data[9] = e>>8; 
003E:  MOVFF  1D,27
....................  
....................       for(x = 0 ; x<10 ; x++){ 
0042:  CLRF   28
0044:  MOVF   28,W
0046:  SUBLW  09
0048:  BNC   0068
....................  
....................         printf("%c",data[x]); 
004A:  CLRF   03
004C:  MOVF   28,W
004E:  ADDLW  1E
0050:  MOVWF  FE9
0052:  MOVLW  00
0054:  ADDWFC 03,W
0056:  MOVWF  FEA
0058:  MOVFF  FEF,29
005C:  MOVF   29,W
005E:  BTFSS  F9E.4
0060:  BRA    005E
0062:  MOVWF  FAD
0064:  INCF   28,F
0066:  BRA    0044
....................  
....................       } 
0068:  GOTO   00DE (RETURN)
.................... } 
.................... void sampling_ADC(){ //@ Realiza las mediciones que existan en el puerto ADC @// 
....................  
....................   int16 medicion[5]; 
....................  
....................   for(int j = 0; j <= 4; j++) 
006C:  CLRF   13
006E:  MOVF   13,W
0070:  SUBLW  04
0072:  BNC   00B4
....................     { 
....................       /*if (j==4) //Cambiar a AN8 
....................       { 
....................          j=8; 
....................          set_adc_channel(j); 
....................          delay_us(20); 
....................          medicion[j-4] = read_adc(); 
....................       } 
....................       */ 
....................       //else 
....................       //{ 
....................          set_adc_channel(j); 
0074:  RLCF   13,W
0076:  MOVWF  00
0078:  RLCF   00,F
007A:  MOVLW  FC
007C:  ANDWF  00,F
007E:  MOVF   FC2,W
0080:  ANDLW  C3
0082:  IORWF  00,W
0084:  MOVWF  FC2
....................          delay_us(20); 
0086:  MOVLW  20
0088:  MOVWF  00
008A:  DECFSZ 00,F
008C:  BRA    008A
008E:  BRA    0090
0090:  NOP   
....................          medicion[j] = read_adc(); 
0092:  BCF    FD8.0
0094:  RLCF   13,W
0096:  CLRF   03
0098:  ADDLW  09
009A:  MOVWF  FE9
009C:  MOVLW  00
009E:  ADDWFC 03,W
00A0:  MOVWF  FEA
00A2:  BSF    FC2.1
00A4:  BTFSC  FC2.1
00A6:  BRA    00A4
00A8:  MOVFF  FC3,FEF
00AC:  MOVFF  FC4,FEC
00B0:  INCF   13,F
00B2:  BRA    006E
....................         // } 
....................     } 
....................  
....................     send_info_rs232(medicion[0],medicion[1],medicion[2],medicion[3],medicion[4]); 
00B4:  MOVFF  0A,15
00B8:  MOVFF  09,14
00BC:  MOVFF  0C,17
00C0:  MOVFF  0B,16
00C4:  MOVFF  0E,19
00C8:  MOVFF  0D,18
00CC:  MOVFF  10,1B
00D0:  MOVFF  0F,1A
00D4:  MOVFF  12,1D
00D8:  MOVFF  11,1C
00DC:  BRA    001A
00DE:  GOTO   0362 (RETURN)
.................... } 
.................... void calibracion(){ 
*
015C:  BSF    09.0
015E:  BSF    09.1
....................  
....................     int1 limit_1 = 1,limit_2 = 1; 
....................     do { 
....................  
....................        if(limit_1 == 1){ 
0160:  BTFSS  09.0
0162:  BRA    018A
....................          if(input(PIN_D0)){ 
0164:  BSF    F95.0
0166:  BTFSS  F83.0
0168:  BRA    017C
....................            motor_s(1,'O','>'); 
016A:  MOVLW  01
016C:  MOVWF  0B
016E:  MOVLW  4F
0170:  MOVWF  0C
0172:  MOVLW  3E
0174:  MOVWF  0D
0176:  RCALL  00E2
....................            limit_1 = 0; 
0178:  BCF    09.0
....................          } 
017A:  BRA    018A
....................          else{ 
....................            motor_s(1,'I','<'); 
017C:  MOVLW  01
017E:  MOVWF  0B
0180:  MOVLW  49
0182:  MOVWF  0C
0184:  MOVLW  3C
0186:  MOVWF  0D
0188:  RCALL  00E2
....................  
....................          } 
....................        } 
....................        if(limit_2 == 1){ 
018A:  BTFSS  09.1
018C:  BRA    01B4
....................          if(input(PIN_D1)){ 
018E:  BSF    F95.1
0190:  BTFSS  F83.1
0192:  BRA    01A6
....................            motor_s(2,'O','>'); 
0194:  MOVLW  02
0196:  MOVWF  0B
0198:  MOVLW  4F
019A:  MOVWF  0C
019C:  MOVLW  3E
019E:  MOVWF  0D
01A0:  RCALL  00E2
....................            limit_2 = 0; 
01A2:  BCF    09.1
....................          } 
01A4:  BRA    01B4
....................          else{ 
....................            motor_s(2,'I','<'); 
01A6:  MOVLW  02
01A8:  MOVWF  0B
01AA:  MOVLW  49
01AC:  MOVWF  0C
01AE:  MOVLW  3C
01B0:  MOVWF  0D
01B2:  RCALL  00E2
....................          } 
....................         } 
....................     } while((limit_1 != 0)||(limit_2 != 0)); 
01B4:  BTFSC  09.0
01B6:  BRA    0160
01B8:  BTFSC  09.1
01BA:  BRA    0160
....................  
....................     char end = 'c'; 
01BC:  MOVLW  63
01BE:  MOVWF  0A
....................  
....................     printf("%c",end); 
01C0:  MOVF   0A,W
01C2:  BTFSS  F9E.4
01C4:  BRA    01C2
01C6:  MOVWF  FAD
01C8:  GOTO   0362 (RETURN)
.................... } 
.................... int r_datos(void){ 
....................   char bucle; 
....................     bucle = getc(); 
01CC:  BTFSS  F9E.5
01CE:  BRA    01CC
01D0:  MOVFF  FAE,09
....................     return bucle; 
01D4:  MOVFF  09,01
01D8:  GOTO   031C (RETURN)
.................... } 
.................... void corte_maquina(void){ 
....................  
.................... output_high(PIN_B0); 
*
0228:  BCF    F93.0
022A:  BSF    F8A.0
.................... delay_ms(500); 
022C:  MOVLW  02
022E:  MOVWF  09
0230:  MOVLW  FA
0232:  MOVWF  0A
0234:  RCALL  0202
0236:  DECFSZ 09,F
0238:  BRA    0230
.................... output_high(PIN_B1); 
023A:  BCF    F93.1
023C:  BSF    F8A.1
.................... delay_ms(500); 
023E:  MOVLW  02
0240:  MOVWF  09
0242:  MOVLW  FA
0244:  MOVWF  0A
0246:  RCALL  0202
0248:  DECFSZ 09,F
024A:  BRA    0242
.................... output_high(PIN_B2); 
024C:  BCF    F93.2
024E:  BSF    F8A.2
.................... delay_ms(500); 
0250:  MOVLW  02
0252:  MOVWF  09
0254:  MOVLW  FA
0256:  MOVWF  0A
0258:  RCALL  0202
025A:  DECFSZ 09,F
025C:  BRA    0254
.................... output_high(PIN_B3); 
025E:  BCF    F93.3
0260:  BSF    F8A.3
.................... delay_ms(500); 
0262:  MOVLW  02
0264:  MOVWF  09
0266:  MOVLW  FA
0268:  MOVWF  0A
026A:  RCALL  0202
026C:  DECFSZ 09,F
026E:  BRA    0266
0270:  GOTO   0330 (RETURN)
....................  
....................  
.................... } 
.................... void motor_s(int num_motor,char estado,char direccion){ 
....................  
....................   switch (num_motor) { 
*
00E2:  MOVF   0B,W
00E4:  XORLW  01
00E6:  BZ    00EE
00E8:  XORLW  03
00EA:  BZ    0124
00EC:  BRA    015A
....................     case 1:{ // ELEGIR MOTOR 1 
....................       switch (estado) { 
00EE:  MOVF   0C,W
00F0:  XORLW  49
00F2:  BZ    00FA
00F4:  XORLW  06
00F6:  BZ    011A
00F8:  BRA    0122
....................         case 'I':{ // SELECCIONA ON 
....................             switch (direccion) { 
00FA:  MOVF   0D,W
00FC:  XORLW  3E
00FE:  BZ    0106
0100:  XORLW  02
0102:  BZ    0110
0104:  BRA    0118
....................               case '>':{ // DIRECCION ADELANTE 
....................                 output_high(motor_pin_1); 
0106:  BCF    F93.0
0108:  BSF    F8A.0
....................                 output_low(motor_pin_2); 
010A:  BCF    F93.1
010C:  BCF    F8A.1
....................                 break; 
010E:  BRA    0118
....................               } 
....................               case '<':{ // DIRECCION ATRAS 
....................                 output_high(motor_pin_2); 
0110:  BCF    F93.1
0112:  BSF    F8A.1
....................                 output_low(motor_pin_1); 
0114:  BCF    F93.0
0116:  BCF    F8A.0
....................                 break; 
....................               } 
....................             } 
....................           break; 
0118:  BRA    0122
....................         } 
....................         case 'O':{ // SELECCIONA OFF 
....................           output_low(motor_pin_1); 
011A:  BCF    F93.0
011C:  BCF    F8A.0
....................           output_low(motor_pin_2); 
011E:  BCF    F93.1
0120:  BCF    F8A.1
....................  
....................           break; 
....................         } 
....................       } 
....................       break; 
0122:  BRA    015A
....................     } 
....................     case 2:{ // ELEGIR MOTOR 2 
....................       switch (estado) { 
0124:  MOVF   0C,W
0126:  XORLW  49
0128:  BZ    0130
012A:  XORLW  06
012C:  BZ    0150
012E:  BRA    0158
....................         case 'I':{ // SELECCIONA ON 
....................             switch (direccion) { 
0130:  MOVF   0D,W
0132:  XORLW  3E
0134:  BZ    013C
0136:  XORLW  02
0138:  BZ    0146
013A:  BRA    014E
....................               case '>':{ // DIRECCION ADELANTE 
....................                 output_high(motor_pin_3); 
013C:  BCF    F93.2
013E:  BSF    F8A.2
....................                 output_low(motor_pin_4); 
0140:  BCF    F93.3
0142:  BCF    F8A.3
....................                 break; 
0144:  BRA    014E
....................               } 
....................               case '<':{ // DIRECCION ATRAS 
....................                 output_high(motor_pin_4); 
0146:  BCF    F93.3
0148:  BSF    F8A.3
....................                 output_low(motor_pin_3); 
014A:  BCF    F93.2
014C:  BCF    F8A.2
....................                 break; 
....................               } 
....................             } 
....................           break; 
014E:  BRA    0158
....................         } 
....................         case 'O':{ // SELECCIONA OFF 
....................           output_low(motor_pin_3); 
0150:  BCF    F93.2
0152:  BCF    F8A.2
....................           output_low(motor_pin_4); 
0154:  BCF    F93.3
0156:  BCF    F8A.3
....................           break; 
....................         } 
....................       } 
....................       break; 
0158:  BRA    015A
....................     } 
....................   } 
015A:  RETURN 0
.................... } 
.................... char sensor_start(void){ 
....................  
....................   do { 
....................     motor_s(1,'I','>'); 
*
0274:  MOVLW  01
0276:  MOVWF  0B
0278:  MOVLW  49
027A:  MOVWF  0C
027C:  MOVLW  3E
027E:  MOVWF  0D
0280:  RCALL  00E2
....................   } while((input(limit_sensor)) != 1); 
0282:  BSF    F95.3
0284:  BTFSS  F83.3
0286:  BRA    0274
....................   motor_s(1,'O',' '); 
0288:  MOVLW  01
028A:  MOVWF  0B
028C:  MOVLW  4F
028E:  MOVWF  0C
0290:  MOVLW  20
0292:  MOVWF  0D
0294:  RCALL  00E2
....................   return 'n'; 
0296:  MOVLW  6E
0298:  MOVWF  01
029A:  GOTO   033C (RETURN)
.................... } 
.................... void cut_start(void){ 
....................  
....................   do { 
....................     motor_s(1,'I','<'); 
*
01DC:  MOVLW  01
01DE:  MOVWF  0B
01E0:  MOVLW  49
01E2:  MOVWF  0C
01E4:  MOVLW  3C
01E6:  MOVWF  0D
01E8:  RCALL  00E2
....................   } while((input(l_1)) != 1); 
01EA:  BSF    F95.0
01EC:  BTFSS  F83.0
01EE:  BRA    01DC
....................    motor_s(1,'O',' '); 
01F0:  MOVLW  01
01F2:  MOVWF  0B
01F4:  MOVLW  4F
01F6:  MOVWF  0C
01F8:  MOVLW  20
01FA:  MOVWF  0D
01FC:  RCALL  00E2
01FE:  GOTO   0322 (RETURN)
.................... } 

Configuration Fuses:
   Word  1: CC04   PLL5 CPUDIV1 NOUSBDIV HS FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
